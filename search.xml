<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>View的创建流程</title>
    <url>/2020/07/24/View%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="View的创建流程"><a href="#View的创建流程" class="headerlink" title="View的创建流程"></a>View的创建流程</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><img src="/2020/07/24/View%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B.png" class title="布局流程">

<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><ul>
<li><p>performLaunchActivity(ActivityClientRecord r, Intent customIntent)，在这个方法中进行一系列初始化工作</p>
</li>
<li><p>ContextImpl appContext = createBaseContextForActivity(r)，进行上下文初始化</p>
</li>
<li><p>activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent)，进行activity的初始化</p>
</li>
<li><p>window = r.mPendingRemoveWindow，创建一个window，但是此时的window为null</p>
<ul>
<li><p>r.mPendingRemoveWindow = r.window</p>
</li>
<li><p>r.window = r.activity.getWindow()</p>
</li>
<li><p>所以说window是从Activity类中的getWindow()里获取的</p>
</li>
<li><pre><code class="java">    <span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> mWindow;
    }
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ul>
<p>通过这个方法把window与activity进行绑定，实际上是在attach方法中调用了 mWindow = new PhoneWindow(this, window, activityConfigCallback)，创建了一个新的PhoneWindow。</p>
</li>
<li><p>此时的结构：</p>
<img src="/2020/07/24/View%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BB%93%E6%9E%84.png" class title="第一次结构">
</li>
<li><p>mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState)，呼叫activity调用oncreate方法</p>
</li>
</ul>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><ul>
<li><p>在OnCreate中调用setContentView方法加载布局文件</p>
</li>
<li><p>installDecor()，对decor进行一系列操作</p>
<ul>
<li><p>mDecor = generateDecor(-1)，初始化decor，return new DecorView(context, featureId, this, getAttributes())，返回一个DecorView。</p>
</li>
<li><p>mContentParent = generateLayout(mDecor)，PhoneWindow中的 mContentParent的初始化，其实就是一个DecorView。</p>
</li>
<li><p>generateLayout(mDecor)中，mDecor.onResourcesLoaded(mLayoutInflater, layoutResource)</p>
<ul>
<li>layoutResource就是传入的布局文件</li>
<li>mLayoutInflater为布局加载器</li>
<li>final View root = inflater.inflate(layoutResource, null)</li>
<li>addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT))</li>
<li>通过前两步把布局文件加载为View并且添加进去</li>
</ul>
</li>
<li><p>此时状态：</p>
<img src="/2020/07/24/View%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%BB%93%E6%9E%84.png" class title="第二次结构">
</li>
</ul>
</li>
<li><p>mLayoutInflater.inflate(layoutResID, mContentParent)</p>
<ul>
<li>final View temp = createViewFromTag(root, name, inflaterContext, attrs)<ul>
<li>view = createView(name, null, attrs)，在这个函数里通过反射调用有两个参数的构造函数进行初始化</li>
<li>view = mFactory2.onCreateView(parent, name, context, attrs)，Factory2是一个接口，提供OnCreateView方法，让开发者可以继承接口去实现View的初始化过程中的一些操作，只有当mFactory2不为null时，才会调用这个方法</li>
</ul>
</li>
<li>params = root.generateLayoutParams(attrs)，new一个LayoutParams对象</li>
<li>temp.setLayoutParams(params)，给加载出来的view设置LayoutParams</li>
</ul>
</li>
<li><p>此时状态：</p>
<img src="/2020/07/24/View%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%BB%93%E6%9E%84.png" class title="第三次结构">
</li>
<li><p>关于inflate的attachToRoot参数的解析</p>
<ul>
<li>这里用true,就表示解析出来的view参数用父view的并由系统完成addview</li>
<li>用false,就由用户自己去修改参数后，再手动addview添加到布局中，如果没有写addview，则xml中的属性都获取不到</li>
<li>addview里面有个异常能保证addView中执行一次，也就保证了view的体系结构永远是树型 ，每个节点只有一个父节点</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>事件分发二级联动</title>
    <url>/2020/07/28/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="事件分发和二级联动"><a href="#事件分发和二级联动" class="headerlink" title="事件分发和二级联动"></a>事件分发和二级联动</h1><h2 id="1-事件分发流程"><a href="#1-事件分发流程" class="headerlink" title="1 事件分发流程"></a>1 事件分发流程</h2><img src="/2020/07/28/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/%E5%9B%BE%E7%89%872.png" class title="分发流程">

<ul>
<li><p>从控件回调回activity开始分发，调用dispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">          onUserInteraction();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入PhoneWindow中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入DecorView中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用父类的dispatchTouchEvent方法，而DecorView的父类是FragmentLayout，并没有重写dispatchTouchEvent方法，所以交给它的父类ViewGroup来调用。</p>
</li>
<li><p>从而进一步就进入了View和ViewGroup的树形结构</p>
<img src="/2020/07/28/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/%E5%9B%BE%E7%89%871.png" class title="树形结构">

</li>
</ul>
<h3 id="1-1-事件处理（View）"><a href="#1-1-事件处理（View）" class="headerlink" title="1.1 事件处理（View）"></a>1.1 事件处理（View）</h3><ul>
<li><p>view的dispatchTouchEvent方法</p>
</li>
<li><p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/**这一段最关键</span></span><br><span class="line"><span class="comment">         ListenerInfo li = mListenerInfo;</span></span><br><span class="line"><span class="comment">         if (li != null &amp;&amp; li.mOnTouchListener != null</span></span><br><span class="line"><span class="comment">                 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span></span><br><span class="line"><span class="comment">                 &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span></span><br><span class="line"><span class="comment">             result = true;</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">         <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>​    其中mListenerInfo是只要调用了setOnTouchLisener就会初始化的。</p>
<p>​    判断中的前三个条件都为true，进行到第四个条件的判断，只要OnTouch方法返回的是true，那么result就为true，否则为false。</p>
<p>​    而result为true时，在下一个if语句中，就无法调用到onTouchEvent，无法在其中调用onClick方法，所以这就是为什么onTouch返回值为true时，onClick事件被拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">performClickInternal() -&gt; performClick() -&gt; li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然满足这一切的条件时clickable要为true</p>
</li>
</ul>
<h3 id="1-2-事件分发（ViewGroup）"><a href="#1-2-事件分发（ViewGroup）" class="headerlink" title="1.2 事件分发（ViewGroup）"></a>1.2 事件分发（ViewGroup）</h3><img src="/2020/07/28/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/%E5%9B%BE%E7%89%873.png" class title="事件分发例子">

<h3 id="1-2-1-ACTION-DOWN"><a href="#1-2-1-ACTION-DOWN" class="headerlink" title="1.2.1 ACTION_DOWN"></a>1.2.1 ACTION_DOWN</h3><p>首先会清除所有标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">             <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">             <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">             <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">             cancelAndClearTouchTargets(ev);</span><br><span class="line">             resetTouchState();</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-1-1-拦截"><a href="#1-2-1-1-拦截" class="headerlink" title="1.2.1.1 拦截"></a>1.2.1.1 拦截</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到intercepted被赋值为onInterceptTouchEvent(ev)的返回值。</p>
<p>​    如果被拦截，则intercepted为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted)</span><br></pre></td></tr></table></figure>

<p>​    无法进入这个if语句，去进行与分发相关的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br></pre></td></tr></table></figure>

<p>​    在这一个if语句里进行事件的分发或者处理，进入dispatchTransformedTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在dispatchTransformedTouchEvent里可以看到，因为调用时child此参数传入为null，所以直接调用父类View的dispatchTouchEvent方法，去处理这个事件，即这个事件被拦截在这个ViewGroup。</p>
<h4 id="1-2-1-2-不拦截"><a href="#1-2-1-2-不拦截" class="headerlink" title="1.2.1.2 不拦截"></a>1.2.1.2 不拦截</h4><p>​    如果不拦截，则intercepted为false。</p>
<p>​    进入第二个if语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br></pre></td></tr></table></figure>

<p>如果为ACTION_DOWN就进入这个if语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList()</span><br></pre></td></tr></table></figure>

<p>​    进入这个if语句，并且通过buildTouchDispatchChildList()方法构造一个数组用于存放ViewGroup中的View，并且写在上面的view会放在数组后面，拿也是从数组后面开始拿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br></pre></td></tr></table></figure>

<p>​    进入for循环，遍历当前ViewGroup的所有子View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个条件：</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(@NonNull View child)</span> </span>{
    <span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
            || child.getAnimation() != <span class="keyword">null</span>;
}
&lt;!--￼<span class="number">15</span>--&gt;

这个表示点击区域是否是View所在的区域。
</code></pre>
</li>
</ul>
<p>如果满足其中任意一个，就continue，直接遍历到下一个child。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">    <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果newTouchTarget不为null，就直接结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">    <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                mLastTouchDownIndex = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLastTouchDownIndex = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastTouchDownX = ev.getX();</span><br><span class="line">    mLastTouchDownY = ev.getY();</span><br><span class="line">    <span class="comment">//参数赋值</span></span><br><span class="line">    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这里可以看到，如果dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)返回true，则进入对一些参数进行赋值并且结束循环，如果为false，则继续进行下去开始下一次循环。</p>
<p>​    <strong>在dispatchTransformedTouchEvent方法中，此时child不为null，所以调用child的dispatchTouchEvent方法，即肯定是ViewGroup的。</strong></p>
<p>​    进行完参数赋值之后，newTouchTarget == mFirstTouchTarget，target.next==null，    alreadyDispatchedToNewTouchTarget = true。</p>
<ul>
<li><p>在这个if语句中，如果返回值一直为false，即所有子View都不处理事件，则和拦截的情况没有区别，全部交给当前ViewGroup处理。</p>
</li>
<li><p>如果返回值有true，则带着变化的参数进入第三个if语句</p>
<ul>
<li><p>将进入else</p>
</li>
<li><pre><code class="java"><span class="keyword">while</span> (target != <span class="keyword">null</span>) {
    <span class="keyword">final</span> TouchTarget next = target.next;
    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
        handled = <span class="keyword">true</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)
                || intercepted;
        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,
                target.child, target.pointerIdBits)) {
            handled = <span class="keyword">true</span>;
        }
        <span class="keyword">if</span> (cancelChild) {
            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) {
                mFirstTouchTarget = next;
            } <span class="keyword">else</span> {
                predecessor.next = next;
            }
            target.recycle();
            target = next;
            <span class="keyword">continue</span>;
        }
    }
    predecessor = target;
    target = next;
}
&lt;!--￼<span class="number">18</span>--&gt;

肯定为<span class="keyword">true</span>，所以handled为<span class="keyword">true</span>，函数最终返回<span class="keyword">true</span>，代表这个事件我不处理。


</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-ACTION-MOVE"><a href="#1-2-2-ACTION-MOVE" class="headerlink" title="1.2.2 ACTION_MOVE"></a>1.2.2 ACTION_MOVE</h3>]]></content>
  </entry>
  <entry>
    <title>插件化换肤</title>
    <url>/2020/07/26/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8D%A2%E8%82%A4/</url>
    <content><![CDATA[<h1 id="插件化换肤"><a href="#插件化换肤" class="headerlink" title="插件化换肤"></a>插件化换肤</h1>]]></content>
  </entry>
  <entry>
    <title>自定义View</title>
    <url>/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    <content><![CDATA[<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><h2 id="1-1-什么是自定义View？"><a href="#1-1-什么是自定义View？" class="headerlink" title="1.1 什么是自定义View？"></a>1.1 什么是自定义View？</h2><p>​    自定义View大体上就是三个步骤：</p>
<ul>
<li>布局：onMeasure , onLayout</li>
<li>绘制: onDraw</li>
<li>事件分发：onTouchEvent</li>
</ul>
<h2 id="1-2-自定义View的分类"><a href="#1-2-自定义View的分类" class="headerlink" title="1.2 自定义View的分类"></a>1.2 自定义View的分类</h2><ul>
<li>View类型：实现OnMeasure和OnDraw</li>
<li>ViewGroup类型：实现OnMeasure和OnLayout</li>
</ul>
<h2 id="1-3-基础"><a href="#1-3-基础" class="headerlink" title="1.3 基础"></a>1.3 基础</h2><h3 id="1-3-1-构造函数"><a href="#1-3-1-构造函数" class="headerlink" title="1.3.1 构造函数"></a>1.3.1 构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果View是在Java代码里面new的，则调用第一个构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果View是在.xml里声明的，则调用第二个构造函数 </span></span><br><span class="line"><span class="comment">// 自定义属性是从AttributeSet参数传进来的 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用 </span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用 </span></span><br><span class="line"><span class="comment">// 如View有style属性时 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//API21之后才使用 </span></span><br><span class="line"><span class="comment">// 不会自动调用 </span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用 </span></span><br><span class="line"><span class="comment">// 如View有style属性时 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes&#123; </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-View的视图结构"><a href="#1-3-2-View的视图结构" class="headerlink" title="1.3.2 View的视图结构"></a>1.3.2 View的视图结构</h3><ol>
<li>PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口。</li>
<li>DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属<br>性。它本质上是一个FrameLayout。</li>
<li>ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等。</li>
</ol>
<h3 id="1-3-3-坐标系"><a href="#1-3-3-坐标系" class="headerlink" title="1.3.3 坐标系"></a>1.3.3 坐标系</h3><ul>
<li><p>Android坐标系</p>
<p>(1)以左上角为坐标原点</p>
<p>(2)向右为x轴正方向，向下为y轴正方向</p>
<img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%872.png" class title="Android系统坐标系">
</li>
<li><p>View位置坐标系</p>
<ul>
<li><p>Top：子View上边界到父view上边界的距离</p>
</li>
<li><p>Left：子View左边界到父view左边界的距离</p>
</li>
<li><p>Bottom：子View下边距到父View上边界的距离</p>
</li>
<li><p>Right：子View右边界到父view左边界的距离</p>
</li>
</ul>
<img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%873.png" class title="视图坐标系">
</li>
<li><p>获取位置的方法</p>
<ul>
<li>调用get方法获取相对于父View的距离</li>
<li>在MotionEvent中，get方法获取相对于所在控件坐标系的位置，getRaw方法获取相对于系统坐标系的位置</li>
</ul>
</li>
</ul>
<h3 id="1-3-4-View绘制的生命周期"><a href="#1-3-4-View绘制的生命周期" class="headerlink" title="1.3.4 View绘制的生命周期"></a>1.3.4 View绘制的生命周期</h3><img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%874.png" class title="生命周期">

<h3 id="1-3-5-View的层级结构"><a href="#1-3-5-View的层级结构" class="headerlink" title="1.3.5 View的层级结构"></a>1.3.5 View的层级结构</h3><p>​    View绘制是一个树形结构进行递归绘制，以DecorView为根结点。</p>
<img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%871.png" class title="层级结构">



<h2 id="1-4-MeasureSpec"><a href="#1-4-MeasureSpec" class="headerlink" title="1.4 MeasureSpec"></a>1.4 MeasureSpec</h2><ul>
<li><p>MeasureSpec是一个int类型的变量，用于存储View的大小和模式信息，最高两位，即31，32位，存储mode信息，其余位数存储size信息。</p>
</li>
<li><p>其中mode类型包括：</p>
<ul>
<li>UNSPECIFIED：不对View大小做限制，系统使用</li>
<li>EXACTLY：确切的大小，如：100dp</li>
<li>AT_MOST：大小不可超过某数值，如：matchParent, 最大不能超过你爸爸</li>
</ul>
</li>
</ul>
<h2 id="1-5-LayoutParams"><a href="#1-5-LayoutParams" class="headerlink" title="1.5 LayoutParams"></a>1.5 LayoutParams</h2><p>​    LayoutParams的作用就是告诉父布局你自己的大小，可以通过LayoutParams获取到MeasureSpec。</p>
<p>​    <strong>getChildMeasureSpec(int spec, int padding, int childDimension)</strong></p>
<p>​    这个函数就是获取子布局的MeasureSpec的方法，第一个参数传入父布局的MeasureSpec，第三个就传入子布局LayoutParams中的width或者Height。</p>
<ul>
<li><p>原理</p>
<img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%875.png" class title="规则">



</li>
</ul>
<p>  通俗易懂的一个例子：</p>
  <img src="/2020/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%9B%BE%E7%89%876.png" class title="例子">

<h2 id="1-6-流式布局绘制实战"><a href="#1-6-流式布局绘制实战" class="headerlink" title="1.6 流式布局绘制实战"></a>1.6 流式布局绘制实战</h2><h3 id="1-6-1-onMeasure"><a href="#1-6-1-onMeasure" class="headerlink" title="1.6.1 onMeasure"></a>1.6.1 onMeasure</h3><ul>
<li><p>先度量孩子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> childView = getChildAt(i)</span><br><span class="line"><span class="keyword">val</span> layoutParams = childView.layoutParams</span><br><span class="line"><span class="keyword">val</span> childWidthMeasureSpec = getChildMeasureSpec(</span><br><span class="line">                    widthMeasureSpec,</span><br><span class="line">                    paddingLeft + paddingRight,</span><br><span class="line">                    layoutParams.width</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">val</span> childHeightMeasureSpec = getChildMeasureSpec(</span><br><span class="line">                    heightMeasureSpec,</span><br><span class="line">                    paddingBottom + paddingTop,</span><br><span class="line">                    layoutParams.height</span><br><span class="line">                )</span><br><span class="line">childView.measure(childWidthMeasureSpec, childHeightMeasureSpec)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>再度量自己</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> realWidth =</span><br><span class="line">            <span class="keyword">if</span> (MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY) selfWidth <span class="keyword">else</span> maxLineWidth</span><br><span class="line"><span class="keyword">val</span> realHeight =</span><br><span class="line">            <span class="keyword">if</span> (MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY) selfHeight <span class="keyword">else</span> maxLineHeight</span><br><span class="line">setMeasuredDimension(realWidth, realHeight)</span><br></pre></td></tr></table></figure>

<p>注意：度量自己的时候需要判断自己的mode，如果为EXACTLY，就直接使用自己的大小，不必使用孩子度量后的大小。</p>
</li>
</ul>
<h3 id="1-6-2-onLayout"><a href="#1-6-2-onLayout" class="headerlink" title="1.6.2 onLayout"></a>1.6.2 onLayout</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> left = curL</span><br><span class="line"><span class="keyword">val</span> top = curT</span><br><span class="line"><span class="keyword">val</span> right = left + view.measuredWidth</span><br><span class="line"><span class="keyword">val</span> bottom = top + view.measuredHeight</span><br><span class="line">view.layout(left, top, right, bottom)</span><br></pre></td></tr></table></figure>

<p>调用layout方法进行布局</p>
<h2 id="1-7-ViewPager的wrap-content失效分析"><a href="#1-7-ViewPager的wrap-content失效分析" class="headerlink" title="1.7 ViewPager的wrap_content失效分析"></a>1.7 ViewPager的wrap_content失效分析</h2><h3 id="1-7-1-原因"><a href="#1-7-1-原因" class="headerlink" title="1.7.1 原因"></a>1.7.1 原因</h3><p>先度量了自己，并且设置为满屏。</p>
<h3 id="1-7-2-改正方法"><a href="#1-7-2-改正方法" class="headerlink" title="1.7.2 改正方法"></a>1.7.2 改正方法</h3><p>重写viewPager的onMeasure方法，先度量孩子。</p>
<h2 id="1-8-FlexBoxLayout"><a href="#1-8-FlexBoxLayout" class="headerlink" title="1.8 FlexBoxLayout"></a>1.8 FlexBoxLayout</h2><h3 id="1-8-1-使用"><a href="#1-8-1-使用" class="headerlink" title="1.8.1 使用"></a>1.8.1 使用</h3><p> <a href="https://www.jianshu.com/p/0723ff4123e1" target="_blank" rel="noopener">https://www.jianshu.com/p/0723ff4123e1</a> </p>
]]></content>
  </entry>
</search>
